[{"title":"虫儿飞","url":"/2018/08/29/18/08/虫儿飞/","content":"![](/img/18/08/虫儿飞/1.jpg)\n\n# 参考\n- [《虫儿飞》尤克里里指弹&弹唱曲谱 郑伊健 白熊版](http://www.ukulelecn.com/forum.php?mod=viewthread&tid=146824&highlight=%B3%E6%B6%F9%B7%C9)","tags":["music"]},{"title":"黄油曲奇","url":"/2018/08/23/18/08/黄油曲奇/","content":"# 原味黄油曲奇\n材料|原味|抹茶味|可可味\n:- | :- | :- | :-\n黄油|130g|130g|130g\n糖粉|50g（可适量减少）|50g|50g\n盐|1.5g|1.5g|1.5g\n蛋清|30g|30g|30g\n低筋面粉|90g|85g|80g\n高筋面粉|70g|70g|70g\n杏仁粉|25g|25g|25g\n抹茶/可可粉||10g|15g\n\n# 注意\n## 用料\n- 黄油需要提前拿出来软化，一小时左右（因室温而不同），冬天可以用吹风筒加快软化。软化程度：太软花纹不成型，太硬挤到手抽筋。\n- 加了高粉和蛋清（可以让曲奇口感偏脆，也有助于保持花纹立体）。可以把蛋白换成蛋黄液或者全蛋液，高筋面粉全部换成低筋面粉，但成品的纹路可能也就没有原配方的纹路立体，也会比较容易碎。\n- 糖粉可以根据自己口味适当增减，用白砂糖也行\n- 没有杏仁粉的，也可以不放，其他材料用量不变，基本没影响，只是口感和香味会差一点点。\n\n## 烘烤\n- 烤饼干类的其实不设置固定时间，一般都是随时观察烤箱，观察饼干的上色程度，烤熟了的就先拿出来，没熟的继续烤，所以，千万不要设置好了时间就不管了，一定要随时观察饼干的状态；\n- 烤抹茶味曲奇：烤 5 ~ 10 分钟定型后（曲奇表面油光消失后），请盖上锡纸继续烤20min以上，不然曲奇表面很容易上色，要随时观察曲奇的状态，摸着底部有一点点硬，记住，一点点硬就可以拿出来了，使劲按的话，可能还会有点软，没关系，冷却后就硬\n\n## 出炉\n- 曲奇烤完后冷却后最好密封，不然会回潮的\n- 关于保质期，密封，春天秋天冬天常温25天左右，夏天15天左右，仅供参考，具体时间，根据保存的环境会有所不同\n\n# 烤箱\n|上管|下管|Time\n:- | :- | :- | :-\n预热|180度|180度|5min\n烘烤|160度|160度|20min以上\n\n# 参考\n- [零失败花纹超级立体的黄油曲奇](http://www.xiachufang.com/recipe/102752278/)","tags":["烘培"]},{"title":"蛋挞","url":"/2018/07/24/18/07/蛋挞/","content":"## 配方一\n材料|\n:- | :- \n鸡蛋|2个\n牛奶|110g\n细砂糖|40g\n淡奶油|180g\n速冻挞皮|15个\n位置|中层或中下层\n火候（预热5分钟）|上下：200度\n时间|25分钟\n## 配方二\n材料|\n:- | :- \n鸡蛋|2个\n牛奶|100g\n细砂糖|25g\n淡奶油（或牛奶）|60g\n速冻挞皮|10个\n位置|中层\n火候（预热5分钟）|上下：200度\n时间|20分钟\n## 制作\n- 速冻挞皮解冻，其他材料准备好\n- 将鸡蛋，牛奶，细砂糖和淡奶油混合，搅拌均匀制成蛋挞液\n- 将蛋挞液倒入蛋挞皮，放入预热好的烤箱","tags":["烘培"]},{"title":"戚风蛋糕","url":"/2018/07/23/18/07/戚风蛋糕/","content":"# 戚风蛋糕（或可可味）\n材料|6寸|8寸\n:- | :- | :- \n鸡蛋|3颗（约56g/颗）|5颗（60g/颗以上为佳）\n牛奶|30g|40g\n色拉油|30g|40g\n低筋面粉|55g|85g\n细砂糖（蛋黄糊）|5g|15g\n细砂糖（蛋白霜）|35g|60g\n柠檬汁或白醋（可以不加）|1~2滴|3~5滴\n如要添加可可粉|减少低筋面粉|5g\n可可粉|12g|20g\n### 注意\n工具要无水无油\n蛋清中不可有蛋黄（不易打发）\n### 蛋黄糊\n蛋黄依次加入糖，色拉油，牛奶，可可粉搅拌均匀，姿势无要求\n分几次筛入低筋面粉，用Z字形搅拌均匀\n### 蛋白霜\n蛋白霜加柠檬汁打发\n分三次加入细砂糖\n不可打发过度\n### 蛋糕糊\n蛋白霜分3次加入蛋黄糊\n用炒菜姿势搅拌均匀，不可画圈搅拌\n### 烘烤\n烤箱200度预热5分钟\n放入中下层，上火170，下火160，50分钟\n### 最后\n取出时要倒置（以免收腰）\n冷却后可脱模","tags":["烘培"]},{"title":"哆啦A梦","url":"/2018/07/22/18/07/哆啦A梦/","content":"![](/img/18/07/哆啦A梦/1.jpg)\n![](/img/18/07/哆啦A梦/2.jpg)\n![](/img/18/07/哆啦A梦/3.jpg)\n\n# 参考\n- [名渡山遼尤克里里演奏哆啦A梦之歌](http://www.ukulelecn.com/forum.php?mod=viewthread&tid=97291&highlight=%B6%DF%C0%B2)","tags":["music"]},{"title":"狼人杀规则","url":"/2018/07/04/18/07/狼人杀/","content":"1、警长规则\n（1）第一天未宣布死者之前就进行警长竞选。\n（2）警长竞选后可以退选。\n（3）只有未竞选者可以投票，竞选后退选不能投票。\n（4）如果第一次投票时平票，则平票者再进行一次发言，然后其他人视为退选。依然只有未竞选者能投票。如果再次平票则没有警长。\n（5）狼人可以在警长竞选阶段自爆，如果这样则没有警长。\n\n2、发言规则\n（1）游戏开始前，事先规定警长竞选发言从号码最大或最小的开始。\n（2）第一天白天发言从警长左边（或右边）开始，警长最后发言。第二天换手，以此类推。如果上一天是警长的左手边先开始发言，则接下来的一天就换成警长的右手边先开始发言。\n（3）如果没有警长，则从最后一个死者的左边（或右边）开始发言。\n（4）狼人可以在任何人发言时自爆。自爆后所有发言立即中止。\n\n3、遗言规则(关于遗言各地面杀的规则不一)\n（1）第一天晚上的死者有遗言（无论死了几个）、第二晚只有单个玩家死亡有遗言，出现多死的情况则没有遗言（进阶规则：第二晚开始所有夜里死的玩家均没有遗言，包括第二晚）。所有白天死亡的玩家都有遗言。\n（2）第三天及以后晚上的死者均没有遗言（若在第（1）条遗言规则中采取了进阶规则，则忽略此条）。\n（3）情侣殉情视为同时死亡。\n（4）猎人枪杀目标视为与猎人同一时间死亡（即猎人白天死，则枪杀目标视为白天死；猎人夜晚死，则枪杀目标视为夜晚死）。\n（5）女巫毒杀目标视为夜晚死亡。\n（6）狼人自爆可以留遗言（又称为指刀）。\n（7）狼人在第一天警长竞选时自爆，第一天夜晚的死者依然可以发表遗言。\n注：另有一份遗言规则是：有几狼就有几遗言，用完为止。比如12人标准屠边局，配置有4狼，则遗言数为4个，无论白天死还是夜里死，无论被女巫毒还是猎人带，无论狼自曝或情侣殉情，都占遗言数。\n\n4、投票规则\n（1）投票时所有人根据法官指令同时举票，允许弃票，跟票无效。\n（2）警长的票视为2票(面杀的规则里警长就是2票，1.5票最早是网杀的规则，近来熊猫tv播出的pandakill也沿用了网杀的1.5票规则)。\n（3）当在白天放逐投票环节发生平票时，所有平票者进入PK台，再进行一轮发言，然后平票者不能投票（包括平票的人为警长亦不能投票），其余玩家只能投票给PK台上的嫌疑人。若再次平票则无人被处决，即平安日，将直接进入黑夜。\n（4）被连中情侣的两位玩家，在白天放逐投票环节永远不能互投。例如4号、9号两名玩家被连中情侣，在白天4号玩家被怀疑，且警长也归票了4号，即便大势所趋，9号玩家因为是4号玩家的情侣是不能上票给4号的，9号玩家只能投其他玩家或是弃票。\n\n5、警徽规则\n（1）狼人在警长竞选时自爆，则警徽流失。\n（2）警长因任何原因死亡时，可以移交警徽，获得警徽的玩家成为现任警长。\n（3）警长因任何原因死亡时，可以撕毁警徽，警徽撕毁后，本局将没有警长。\n\n6、规则盲点\n（1）当某个玩家被狼人袭击时，若守卫的守护与女巫的解药同时对其使用，将会导致拯救失败，该名玩家死亡（同守同救失效）。守卫可以自守，但不能连续两晚守同一个目标。\n（2）白痴在白天被高票处决翻牌发动技能免除放逐后，在接下来的游戏中他就没有投票权了，但白痴依然可以按照正常轮次发言，不能插嘴。即白痴翻牌后就成为了场上存活的不能投票的好人，要让其出局狼人必须在夜里刀走白痴（当然女巫的毒药、猎人的枪都是可以带走他的）。白痴若是因为情侣死亡他殉情的则不能发动技能，与情侣一同出局。\n（3）女巫在解药已经用掉后，便不能再知道夜晚被狼人袭击的对象是谁。如无特殊说明，女巫不能自救。\n（4）猎人若在夜晚被女巫毒杀或情侣死亡殉情时，将会得到法官的提示，表明其技能不能发动。如果白天醒来是没有遗言的天数，他将直接被宣布离场，不能留下任何信息。\n（5）预言家只能验证某位玩家是否是狼人，除了是否狼人以外的一切信息均不能验证（情侣、内奸、非狼坏身份等等），如果预言家验中丘比特，法官无需计较丘比特是哪方阵营，永远只出示好人手势。\n（6）狼刀在先原则：狼人杀害玩家，且女巫不使用解药，若此时已达成狼人胜利条件，则直接判定狼人胜利。即使女巫之后毒杀或猎人开枪带走最后一个狼人也无效。\n（7）狼人刀法：允许空刀、允许自刀，无法统一意见则视为空刀。\n\n\n【法官必须要知道的】\n法官主持发言流程与套路：\n天黑请闭眼，请大家确认好自己的身份后低头闭眼靠后坐…\n盗贼请睁眼，盗贼请选牌…盗贼请闭眼…\n丘比特请睁眼，丘比特请向法官出示两个数字，这两个数字玩家将成为本局的情侣…丘比特请闭眼…\n请大家依然保持闭眼，并将自己的右手伸向前方，手掌心向上，法官会轻轻触碰被连的两名玩家的手掌心…被点中的两名玩家将成为本局游戏的情侣…好了，请将你们的手伸回…\n情侣请睁眼，情侣请互相认识…情侣请闭眼…\n守卫请睁眼，守卫请选择一名你要守护的玩家数字…守卫请闭眼…\n长老请睁眼，长老请看向法官…长老请闭眼…\n狼人请睁眼，狼人请互相认识，狼人请统一意见出示一名今晚要击杀的玩家数字…狼人请闭眼…\n女巫请睁眼，女巫，今夜死亡的是这个玩家数字(出示数字手势但不说话)，如果你要使用解药请出示大拇指，如果你要使用毒药请直接出示你要毒的数字手势…女巫请闭眼。\n预言家请睁眼，预言家请验人…大拇指向上表示好人，大拇指向下表示狼人，你要验的是(出示验人手势但不说话)…预言家请闭眼…\n猎人请睁眼，猎人，大拇指向上表示你的技能出局后可以正常发动，大拇指向下表示你的技能失效，你的技能是(出示手势但不说话)…猎人请闭眼…\n白痴请睁眼，白痴请看向法官…白痴请闭眼…\n天亮了，现在开始警长竞选，竞选开始！\n……\n警长竞选投票环节主持发言：\n好，警上发言结束，仍然坚持竞选的玩家请将自己的数字放在胸前，警上退水的玩家无投票权，其余未参与竞选的玩家在我倒数三秒后统一举票至头顶，允许弃票，跟票无效！三，二，一…\n……\n放逐投票环节主持发言：\n好，所有玩家发言结束，现在进行放逐投票，我倒数三秒后所有玩家统一举票，允许弃票，跟票无效！三，二，一…\n……\nPK台投票环节主持发言：\nx号玩家和y号玩家此轮平票，进入PK台，现在进行PK发言，x号玩家请发言…y号玩家请发言…好，PK发言结束，现在开始投票，请PK台下的玩家在我倒数三秒后统一举票，允许弃票，跟票无效！三，二，一…\n……\n注：请法官严格遵守上述主持的规范用语，不得给场外，必要环节不得跳过！\n——————————\n法官黑夜主持睁眼的顺序依次为：盗贼——丘比特——情侣——守卫——长老——狼人——女巫——预言家——猎人——白痴……（此顺序为第一夜，第二夜开始直接从守卫开始）\n若游戏身份配置中没有加入某个身份则按照上述顺序直接跳过就行。长老和守卫两张神牌一般不建议同时存在。\n注意：\n（1）给盗贼选牌时不能留下场外信息，若盗贼在底牌中或是盗贼埋了丘比特及任一神牌，法官的发言顺序还是要遵守上述的身份顺序的，不能跳过不能省略。\n（2）丘比特在选定情侣、经法官确认后，法官便要指示丘比特闭眼（当然丘比特本人也可以成为情侣的一方）。情侣睁眼后不可以亮牌给对方看，但可以通过手势、暗语等信息传递身份信息，情侣只有在第一晚有睁眼的环节。\n（3）守卫若连续两晚守了同一目标会得到法官的提醒，必须要求其改守。\n（4）狼人出刀允许通过手势、眼神、暗语讨论，但最终必须要统一亮出要击杀的玩家数字，否则视为意见不统一，空刀处理。\n（5）女巫在解药未用之前的夜晚，法官会向其出示当晚被狼人击杀的数字，如果女巫要用解药直接点头或给个大拇指，如果女巫要用毒药则直接向法官出示要毒的数字。不采取任何行动则直接摇头示意法官后闭眼。女巫一个晚上只能用一瓶药，整局游戏只有两瓶药。\n（6）法官给预言家的验人信息只有好人和坏人（狼人）两种手势，预言家验不出人狼第三方、三方丘比特、神牌等具体信息。\n（7）猎人每晚睁眼，如果存活或是被狼人刀死会得到法官肯定的指示，表明其技能可以发动。如果猎人被女巫毒死或是他是情侣中殉情的一方则会得到法官否定的指示，表明其技能不能发动。例如4号玩家和9号玩家被连为情侣，9号玩家是猎人，4号玩家当晚被刀，9号玩家则殉情，白天法官公布死者后9号猎人将不能发动技能，没有遗言的天数更是不能留下任何信息。同样的，如果4号玩家白天被归票出局，那么法官会同时宣布9号玩家殉情出局，此时9号猎人也是不能开枪的，但因为是死在白天，情侣双方都有遗言。上述两种情况反一下，夜里被刀的是9号猎人或白天被票出去的是9号猎人，那么殉情方就是4号玩家了，此时9号猎人是可以开枪的。\n（8）如果情侣倒在夜里，法官白天则直接公布几位玩家死亡就行。如果情侣一方在白天被票死，法官在宣布该玩家出局后要立即宣布情侣中的另一方“殉情”。两者都有遗言。\n（9）猎人在翻牌开枪带人自证后，法官在黑夜则可以省略猎人睁眼的环节。如果有玩家出局遗言说自己是猎人走的，最终选择不开枪，那么法官黑夜主持还是要报猎人的环节，不能省略。\n（10）若场上狼人和第三方人狼情侣已全部出局，丘比特存活，此时游戏仍视为第三方阵营存在，游戏继续，因为丘比特夜里不能刀人，在接下来的游戏进程中会一直出现平安夜，好人需找出丘比特将其弄出局好人阵营方能胜利。\n（11）长老因意外死亡（女巫毒、猎人枪、白天票）导致好身份牌失去技能后的夜里，法官的发言顺序和套路是不变的。即还是要按流程走一遍，只不过要向神牌表明不能用技能了。例如在长老死后，法官在夜里还是要这么发言“预言家请睁眼，请验人，这个是好人，这个是坏人，你要验的是这个。”但实际已不再给出验人手势了。女巫、猎人同理（女巫如果在长老死之前解药没用的，法官还是要向女巫指示刀法，只不过女巫如果选择用药法官只会摇头示意其不能用技能了）。 \n\n【狼人杀身份介绍】\n村民：夜里全程闭眼，白天根据场上玩家的发言、投票行为等找出狼人，呼吁好人将其归出。\n\n狼人：每晚睁眼与狼队友统一意见后击杀一位玩家，白天则混在好人中，在避免自己被怀疑的同时又要引导好人将其他好身份投票出局。\n\n预言家：一张神牌，每晚睁眼验一位玩家的身份，会得到法官给出的是好人还是坏人（狼人）的手势提示。\n\n女巫：一张神牌，拥有两瓶药，一瓶是解药，一瓶是毒药。女巫每晚睁眼选择是否用药，解药可以救起当晚被狼人击杀的玩家，毒药可以毒走一位玩家。女巫在一个晚上只能用一瓶药，且整局游戏只有两瓶药。如无特殊说明，女巫不能自救。\n\n猎人：一张神牌，在被狼人刀死或被投票出局时可以翻牌发动技能开枪带走一位玩家与他同时出局。当猎人被毒死或殉情时将不能发动技能。\n\n守卫：一张神牌，每晚睁眼选择守护一位玩家，若该名玩家被狼人刀中则狼刀无效，该名玩家依旧存活。守卫可以自守，但不能连续两晚守同一个目标。守卫的守护和女巫的解药在一个晚上同时用在了同一个目标身上，守护和解药失效，该名玩家依旧死亡。守卫的守护也守不了女巫的毒药，即守护只能挡狼刀。守卫牌一般不建议与长老牌同时存在。\n\n长老：一张神牌，拥有两条命，狼人需刀长老两刀才能将其刀死。若狼人刀中长老第一条命，女巫当晚将得不到法官的刀法指示；若狼人刀中长老第二条命，女巫会得到法官的刀法指示，若女巫对其用解药救起，则救起的长老只有一条命。长老若被女巫毒死、白天票死、猎人带走则一击毙命。做为惩罚，在接下来的游戏中所有拥有技能的好身份牌技能全部失效（预言家不能验人、女巫不能用药、猎人开不了枪、白痴不能免除放逐/白痴已翻牌的要判离场，等等），长老被狼人杀死或因为情侣死亡长老殉情的不会失去技能。长老牌一般不建议与守卫牌同时存在。\n\n白痴：一张神牌(或民牌，依照相应屠边局规则改变)，白痴若在白天放逐投票环节被投票出局可以翻牌发动技能免除放逐，仍视为存活。在接下来的游戏中白痴按照正常轮次发言，但不再拥有投票权。狼人要将翻牌后的白痴弄出局必须要在夜里将其刀死。\n\n丘比特：在游戏开始的第一晚指定两名玩家成为情侣，丘比特也可以将自己与另一名玩家连成情侣。在这之后，情侣睁眼互相认识，确认身份。在接下来的游戏中，两名情侣中的一个死去时，另一名也立即殉情死去。在白天放逐投票环节，一名情侣永远不能投票给另一名情侣。如果被连中的两名情侣，一个是狼人，另一个是好人，此时场上这对情侣与丘比特形成人狼第三方阵营，第三方阵营的胜利条件是将其余所有玩家都杀死（包括狼人和好人）。丘比特的胜利条件：如果听出两名被连中的玩家是好人，则帮好人阵营玩；听出连中人狼了，则与人狼情侣形成第三方阵营；听出连中两狼，通常情况下帮狼人阵营玩（根据人数身份配置规则做相应调整）。在屠边规则中，丘比特既不是神牌也不是民牌。\n\n盗贼：如果使用盗贼，在游戏开始的时候加入两张额外的普通村民牌，法官洗混身份牌并依次发牌后，留下多余的两张牌做为底牌。抽中盗贼牌的玩家在第一晚第一个睁眼，法官会向其出示两张底牌的身份信息，盗贼必须在这两张牌中选择一个身份，在接下来的游戏中盗贼即成为该身份进行整局游戏，并适用该身份的胜利条件。偶尔可能出现没有盗贼的局，即盗贼牌本身就在两张底牌中（但此时底牌不能为一盗贼一狼，法官要调控）。在供盗贼选择的两张底牌中也不可能出现两狼（法官调控）。若两张底牌中有一张狼人牌，盗贼必须选择狼人，另一身份牌将被埋掉，即本局游戏中不会有另一身份牌。\n\n警长：警长不是一张身份牌，而是一张标志牌，可以跟身份牌一起使用。在第一天未公布死者之前投票竞选产生。任何身份牌都可以参与警长竞选。所有参与警长竞选的玩家按照预定顺序依次发言后，未参与竞选的玩家依据法官指令统一举票，获得高票的竞选者当选为警长。在警长竞选的过程中竞选者随时可以退选，但退选后没有投票权。做为警长，在白天发言总是最后一个发言，他有归票发言权且他的1票视为2票。警长死亡后，可以将警徽传给场上存活的任一玩家，让其继承警长权力，也可以选择撕掉警徽，则接下来的游戏中没有警长。\n\n\n【狼人杀人数身份配置规则建议】\n7/8人2狼丘比特屠城局\n1、身份配置•7/8人\n女巫、预言家、丘比特、狼人*2、普通村民*2/3\n2、各阵营胜利条件：\n人类阵营：杀死所有狼人及坏身份\n狼人阵营：杀死除狼人以外的所有人（即：屠城）\n情侣阵营：若两位情侣的身份为同一阵营（双人、双狼），则帮助原本阵营获胜。若两位情侣的身份为对立阵营（即人狼恋），则必须杀死除丘比特以外所有玩家，成为第三阵营单独获胜\n3、丘比特胜利条件：\n无论情侣属于何阵营，都帮助情侣所在阵营获胜（人人帮好人，狼狼帮狼人，人狼形成第三方）\n规则调整: 因人数少且只有两神，如果女巫被首刀允许自救，注意仅限第一晚。第二晚开始女巫被刀不再能自救。 \n\n\n9人3狼2神3民丘比特屠城局\n1、身份配置•9人\n女巫、预言家、丘比特、狼人*3、普通村民*3\n2、各阵营胜利条件：\n人类阵营：杀死所有狼人及坏身份\n狼人阵营：杀死除狼人以外的所有人（即：屠城）\n情侣阵营：若两位情侣的身份为同一阵营（双人、双狼），则帮助原本阵营获胜。若两位情侣的身份为对立阵营（即人狼恋），则必须杀死除丘比特以外所有玩家，成为第三阵营单独获胜\n3、丘比特胜利条件：\n（1）若情侣为双人，则丘比特帮助人类阵营获胜\n（2）若情侣为人狼恋，则丘比特帮助人狼恋获胜，人狼恋情侣与丘比特捆绑获胜，即便情侣已死，丘比特独活至最后依然视为3人共同获胜，同理若丘比特死亡但情侣存活至最后，也为3人共同获胜\n（3）若情侣为双狼，则丘比特帮助人类阵营获胜\n规则调整: 因为只有两神，如果女巫被首刀允许自救，注意仅限第一晚。第二晚开始女巫被刀不再能自救。 \n\n\n9人标准屠城局\n1、身份配置•9人\n猎人、女巫、预言家、狼人*3、普通村民*3\n2、各阵营胜利条件：\n人类阵营：杀死所有狼人及坏身份\n狼人阵营：杀死除狼人以外的所有人（即：屠城） \n\n\n10人333丘比特屠城局\n1、身份配置•10人\n猎人、女巫、预言家、丘比特、狼人*3、普通村民*3\n2、各阵营胜利条件：\n人类阵营：杀死所有狼人及坏身份\n狼人阵营：杀死除狼人以外的所有人（即：屠城）\n情侣阵营：若两位情侣的身份为同一阵营（双人、双狼），则帮助原本阵营获胜。若两位情侣的身份为对立阵营（即人狼恋），则必须杀死除丘比特以外所有玩家，成为第三阵营单独获胜\n3、丘比特胜利条件：\n无论情侣属于何阵营，都帮助情侣所在阵营获胜（人人帮好人，狼狼帮狼人，人狼形成第三方） \n\n\n11人四狼丘比特屠城局\n1、身份配置•11人\n猎人、女巫、预言家、丘比特、狼人*4、普通村民*3\n2、各阵营胜利条件：\n人类阵营：杀死所有狼人及坏身份\n狼人阵营：杀死除狼人以外的所有人（即：屠城）\n情侣阵营：若两位情侣的身份为同一阵营（双人、双狼），则帮助原本阵营获胜。若两位情侣的身份为对立阵营（即人狼恋），则必须杀死除丘比特以外所有玩家，成为第三阵营单独获胜\n3、丘比特胜利条件：\n（1）若情侣为双人，则丘比特帮助人类阵营获胜\n（2）若情侣为人狼恋，则丘比特帮助人狼恋获胜，人狼恋情侣与丘比特捆绑获胜，即便情侣已死，丘比特独活至最后依然视为3人共同获胜，同理若丘比特死亡但情侣存活至最后，也为3人共同获胜\n（3）若情侣为双狼，则丘比特帮助人类阵营获胜\n这里要说句题外话，之所以双狼情侣，丘比特帮助人类获胜，是因为现有的人数与身份配置的限制：如果双狼情侣， 丘比特帮助狼人获胜，则狼人第一夜击杀一名玩家后，丘比特与4狼直接绑票可得5票，而人类此时只剩下5名玩家。狼人若拿到警徽则可直接获胜。因此狼情侣就有一种开挂玩法，夜晚砍死一名玩家后，狼情侣之一竞选警长，让狼人与丘比特直接绑票推上警长，然后裸打。 \n\n\n444标准屠边局\n1、身份配置•12人\n猎人、女巫、预言家、守卫（或白痴或长老）、普通村民*4、狼人*4\n2、各阵营胜利条件：\n人类阵营：杀死所有狼人及坏身份\n狼人阵营：杀死所有神民或平民（即屠边） \n\n\n12人丘比特盗贼局\n1、身份配置•12人\n猎人、女巫、预言家、白痴、丘比特、盗贼、普通村民*5、狼人*3\n2、各阵营胜利条件：\n人类阵营：杀死所有狼人及坏身份\n狼人阵营：杀死所有神民或平民（即屠边）\n情侣阵营：若两位情侣的身份为同一阵营（双人、双狼），则帮助原本阵营获胜。若两位情侣的身份为对立阵营（即人狼恋），则必须杀死除丘比特以外所有玩家，成为第三阵营单独获胜\n3、丘比特胜利条件：\n无论情侣属于何阵营，都帮助情侣所在阵营获胜（人人帮好人，狼狼帮狼人，人狼形成第三方）\n4、盗贼身份说明：\n（1）一共14张身份牌，洗混之后抽出两张身份牌。第一天夜晚，盗贼首先睁眼，从2张身份牌中选择1张，从此盗贼即成为该身份，并适用该身份的胜利条件\n（2）偶尔可能出现没有盗贼的局（即盗贼在抽出的两张底牌中）\n（3）盗贼牌中不可能出现2狼、盗贼牌中若有狼，必须选择狼人（法官注意，若两张供盗贼选择的牌中有一狼和一其他身份，就直接给盗贼狼身份，另一身份将被埋）\n5、神民与平民：\n（1）神民：猎人、女巫、预言家、白痴\n（2）平民：普通村民*5\n（3）丘比特既不算神民也不算平民\n（4）盗贼最终选择的身份决定他是神民还是平民 \n\n\n\n【特别说明】\n遵守以下规则会让这个游戏变得更加纯粹，富有逻辑、竞技性又不失趣味性:\n（1）轮到你发言时尽量不要划水，你要尽力的去分析场上的形势，实在一头雾水的也要表明自己的身份。这是个听发言、讲逻辑的游戏，如果每个人都划水“过”就失去了这个游戏的初衷了。 \n（2）不要帖脸发言！帖脸发言就是轮到玩家发言时自己可能真的被冤枉出局了，通过情绪化骂人、脏话的发言来说明自己真的是好身份，或是在发言时通过发毒誓、以场外承诺为担保来自证自己身份的，这些都是不允许的。如果每个好身份都帖脸发毒誓来自证身份，那让狼怎么玩？这终归是个听发言、看行为、讲道理的游戏。 \n（3）玩家发言结束请说个“过”，避免被插话、补话。在轮到某位玩家发言时，其他玩家均不能发言，只能倾听，没有对话，没有反驳，就算在那位玩家发言时说到了之前玩家根本没有说过的话也不能反驳。玩家票型、和跳过的身份也只能自己回忆，其他玩家不能提醒。比如9号玩家发言时说4号玩家投的是6号，且4号跳的是强神，即便4号投的不是6号，也没说过自己是强神4号玩家本身也不能反驳，其他玩家也不能在9号玩家发言时间里提醒和反驳。\n（4）玩家在发言时遇到规则上的问题时可以请教法官，法官会根据问题做出回答。 \n（5）不要留下场外信息、不要故意制造场外信息、也不要聊场外信息。比如某位狼人在夜里刀人时动静有点大，此时旁边闭眼的你察觉到了，在白天发言的时候你可以针对这位玩家，但是你不能聊这个场外信息。\n","tags":["game"]},{"title":"Android一次申请多个动态权限","url":"/2018/07/03/18/07/Android申请动态权限/","content":"# Android一次申请多个动态权限\n今天做一个短信群发软件，需要申请多个权限，遇到点小问题。\n## 在 Android6.0（Api 23）以下的版本，申请权限。\n- 只要在Manifest文件中添加权限：\n\n```java\n// 读写手机状态和身份权限 及 短信权限\n<uses-permission android:name=\"android.permission.READ_PHONE_STATE\" />\n<uses-permission android:name=\"android.permission.SEND_SMS\" />\n```\n## Android在6.0以后就要使用动态权限了，否则程序可能无法进行某些功能操作。 \n- Android 6.0对应的Android SDK等级是23.所以一般是先判断手机的版本是否是6.0以上再进行动态请求权限。\n- 动态申请权限如下:\n\n```java\nif (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.READ_PHONE_STATE)\n        != PackageManager.PERMISSION_GRANTED) {\n    ActivityCompat.requestPermissions(MainActivity.this, new String[]{Manifest.permission.READ_PHONE_STATE}, MY_PERMISSIONS_REQUEST_READ_PHONE_STATE);\n} else {\n    // TODU\n}\n```\n- 其中MY_PERMISSIONS_REQUEST_READ_PHONE_STATE 是自定义的类常量，可以像下面这样在activity中定义：\n\n```java\npublic final static int MY_PERMISSIONS_REQUEST_READ_PHONE_STATE = 1;\n```\n## 一个请求读写手机状态和身份权限和短信权限的实例\n```java\npackage com.example.xiao.sms;\n\nimport android.Manifest;\nimport android.app.ActivityManager;\nimport android.app.PendingIntent;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.pm.PackageManager;\nimport android.net.Uri;\nimport android.os.Build;\nimport android.provider.Settings;\nimport android.support.annotation.NonNull;\nimport android.support.v4.app.ActivityCompat;\nimport android.support.v4.content.ContextCompat;\nimport android.support.v7.app.AlertDialog;\nimport android.support.v7.app.AppCompatActivity;\nimport android.os.Bundle;\nimport android.telephony.SmsManager;\nimport android.view.View;\nimport android.widget.Button;\nimport android.widget.EditText;\nimport android.widget.Toast;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class MainActivity extends AppCompatActivity {\n\n    private EditText phoneNum;\n    private EditText message;\n    private Button sendSMS;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        phoneNum = (EditText)findViewById(R.id.phone_num);\n        message = (EditText)findViewById(R.id.message);\n        sendSMS = (Button) findViewById(R.id.send_message);\n\n        // 这里直接在页面创建的时候请求权限，其实不太好\n        // 一般是在触发某个事件的时候再请求动态权限\n        // 比如点击按钮跳转到一个打电话页面，如果权限通过就跳转，否者提示说没有权限！\n        if (Build.VERSION.SDK_INT >= 23) {// 6.0才用动态权限\n            initPermission();\n        }\n\n        sendSMS.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                    String[] everyNumber = phoneNum.getText().toString().split(\"，\");\n                    String content = message.getText().toString();\n                    for (String anEveryNumber : everyNumber) {\n                        sendMessage(anEveryNumber, content);\n                    }\n                    Toast.makeText(MainActivity.this, \"发送成功！\", Toast.LENGTH_LONG).show();\n                }\n        });\n    }\n\n    public void sendMessage(String phoneNumber,String content){\n        SmsManager sms = SmsManager.getDefault();\n        ArrayList<String> mSMSMessage = sms.divideMessage(content);\n        int messageCount = mSMSMessage.size();\n        android.telephony.SmsManager smsManager = android.telephony.SmsManager.getDefault();\n        Intent itSend = new Intent(\"demo_sms_send_action\");\n        itSend.putExtra(\"phone_num\", phoneNumber);\n        ArrayList<PendingIntent> sentIntents = new ArrayList<PendingIntent>(messageCount);\n        smsManager.sendMultipartTextMessage(phoneNumber, null, mSMSMessage, sentIntents, null);\n    }\n\n    // 申请两个权限，读写手机状态和身份权限 及 短信权限\n    // 首先声明一个数组permissions，将需要的权限都放在里面\n    String[] permissions = new String[]{Manifest.permission.READ_PHONE_STATE,\n            Manifest.permission.SEND_SMS};\n    // 创建一个mPermissionList，逐个判断哪些权限未授予，未授予的权限存储到mPerrrmissionList中\n    List<String> mPermissionList = new ArrayList<>();\n    private final int mRequestCode = 100;// 权限请求码\n\n    private void initPermission() {\n        mPermissionList.clear();// 清空没有通过的权限\n\n        // 逐个判断你要的权限是否已经通过\n        for (int i = 0; i < permissions.length; i++) {\n            if (ContextCompat.checkSelfPermission(this, permissions[i]) != PackageManager.PERMISSION_GRANTED) {\n                mPermissionList.add(permissions[i]);// 添加还未授予的权限\n            }\n        }\n        // 申请权限\n        if (mPermissionList.size() > 0) {// 有权限没有通过，需要申请\n            ActivityCompat.requestPermissions(this, permissions, mRequestCode);\n\n        }else{\n            Toast.makeText(MainActivity.this, \"已授权！\", Toast.LENGTH_LONG).show();\n            // 说明权限都已经通过，可以做你想做的事情去\n        }\n    }\n\n    // 请求权限后回调的方法\n    // 参数： requestCode  是我们自己定义的权限请求码\n    // 参数： permissions  是我们请求的权限名称数组\n    // 参数： grantResults 是我们在弹出页面后是否允许权限的标识数组，\n    // 数组的长度对应的是权限名称数组的长度，数组的数据0表示允许权限，-1表示我们点击了禁止权限\n    @Override\n    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {\n        super.onRequestPermissionsResult(requestCode, permissions, grantResults);\n        boolean hasPermissionDismiss = false;// 有权限没有通过\n        if (mRequestCode == requestCode) {\n            for (int i = 0; i < grantResults.length; i++) {\n                if (grantResults[i] == -1) {\n                    hasPermissionDismiss = true;\n                }\n            }\n            // 如果有权限没有被允许\n            if (hasPermissionDismiss) {\n                showPermissionDialog();// 跳转到系统设置权限页面，或者直接关闭页面，不让他继续访问\n            }else{\n                // 全部权限通过，可以进行下一步操作。。。\n            }\n        }\n    }\n\n\n    /**\n     * 不再提示权限时的展示对话框\n     */\n    AlertDialog mPermissionDialog;\n    String mPackName = \"com.example.xiao.sms\";\n\n    private void showPermissionDialog() {\n        if (mPermissionDialog == null) {\n            mPermissionDialog = new AlertDialog.Builder(this)\n                    .setMessage(\"已禁用权限，请手动授予\")\n                    .setPositiveButton(\"设置\", new DialogInterface.OnClickListener() {\n                        @Override\n                        public void onClick(DialogInterface dialog, int which) {\n                            cancelPermissionDialog();\n\n                            Uri packageURI = Uri.parse(\"package:\" + mPackName);\n                            Intent intent = new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS, packageURI);\n                            startActivity(intent);\n                        }\n                    })\n                    .setNegativeButton(\"取消\", new DialogInterface.OnClickListener() {\n                        @Override\n                        public void onClick(DialogInterface dialog, int which) {\n                            // 关闭页面或者做其他操作\n                            cancelPermissionDialog();\n\n                            // 进程式关闭软件\n                            android.os.Process.killProcess(android.os.Process.myPid());\n                            System.exit(0);\n                            ActivityManager manager = (ActivityManager) getSystemService(ACTIVITY_SERVICE);\n                            manager.killBackgroundProcesses(getPackageName());\n                        }\n                    })\n                    .create();\n        }\n        mPermissionDialog.show();\n    }\n\n    // 关闭对话框\n    private void cancelPermissionDialog() {\n        mPermissionDialog.cancel();\n    }\n}\n```\n示例代码根据实际情况做简单修改就可以用在各种动态权限下。\n**说明：**上面的权限数组可以请求多个权限，也可以只请求一个权限\n\n# 参考\n- [Android一次申请多个动态权限](https://blog.csdn.net/wenzhi20102321/article/details/80487975)","tags":["Android"]},{"title":"AMTEmu.v0.9.2-painter","url":"/2018/06/30/18/06/Adobe破解/","content":"# Adobe 全能软件破解注册机 AMTEmu.v0.9.2-painter\n AMTEmu是一款可用于注册激活PS CS到CC系列的所有产品的注册机。如可以一键破解photoshop cc 2018软件的amtlib.dll文件。\n- [点击下载](https://pan.baidu.com/s/1xTCReO-KWfr3BuhO48FbWA) AMTEmu.v0.9.2-painter\n- [ADOBE下载](https://www.adobe.com/cn/downloads.html?promoid=RL89NGY7&mv=other) 并安装\n### 成功安装后，打开AMTEmu.v0.9.2-painter（以破解photoshop cc 2018为例），选择“adobe photoshop cc 2017”再点击install，没错，就是选择2017版\n![](/img/18/06/Adobe_1.png)\n### 再选择adobe photoshop cc 2018软件安装目录下的“amtlib.dll”文件。一般默认安装目录【C:\\Program Files\\Adobe\\Adobe Photoshop CC 2018】\n![](/img/18/06/Adobe_2.png)\n### 看到OK提示，破解成功\n![](/img/18/06/Adobe_3.png)\n\n# 参考\n- [photoshop cc 2018注册机](https://blog.csdn.net/u010731693/article/details/80647788)","tags":["share"]},{"title":"android调用拨打电话（包括运行时权限及动态权限）","url":"/2018/06/30/18/06/android_Call_Phone/","content":"## android调用拨打电话\n```java\n /**\n     * 拨打电话（跳转到拨号界面，用户手动点击拨打）\n     *\n     * @param phoneNum 电话号码\n     */\n    public void diallPhone(String phoneNum) {\n        Intent intent = new Intent(Intent.ACTION_DIAL);\n        Uri data = Uri.parse(\"tel:\" + phoneNum);\n        intent.setData(data);\n        startActivity(intent);\n    }\n```\n```java\n/**\n     * 拨打电话（直接拨打电话）\n     *\n     * @param phoneNum 电话号码\n     */\n    public void callPhone(String phoneNum) {\n        Intent intent = new Intent(Intent.ACTION_CALL);\n        Uri data = Uri.parse(\"tel:\" + phoneNum);\n        intent.setData(data);\n        startActivity(intent);\n    }\n```\n```java\n<uses-permission android:name=\"android.permission.CALL_PHONE\" />\n```\n## 自动拨打电话在6.0以后即使加了权限也会crash，因为动态权限的问题,解决如下\n```java\nprivate static final int MY_PERMISSIONS_REQUEST_CALL_PHONE = 1;\n// 检查是否获得了权限（Android6.0运行时权限）\nif (ContextCompat.checkSelfPermission(MainActivity.this, \n    Manifest.permission.CALL_PHONE)!= PackageManager.PERMISSION_GRANTED){\n    // 没有获得授权，申请授权\n    Toast.makeText(MainActivity.this, \"请授权！\", Toast.LENGTH_LONG).show();\n    if (ActivityCompat.shouldShowRequestPermissionRationale(MainActivity.this,\n        Manifest.permission.CALL_PHONE)){\n        // 返回值：\n        // 如果app之前请求过该权限,被用户拒绝, 这个方法就会返回true.\n        // 如果用户之前拒绝权限的时候勾选了对话框中”Don’t ask again”的选项,那么这个方法会返回false.\n        // 如果设备策略禁止应用拥有这条权限, 这个方法也返回false.\n        // 弹窗需要解释为何需要该权限，再次请求授权\n        Toast.makeText(MainActivity.this, \"请授权！\", Toast.LENGTH_LONG).show();\n        // 帮跳转到该应用的设置界面，让用户手动授权\n        Intent intent = new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);\n        Uri uri = Uri.fromParts(\"package\", getPackageName(), null);\n        intent.setData(uri);\n        startActivity(intent);\n    } else {\n        // 不需要解释为何需要该权限，直接请求授权\n        ActivityCompat.requestPermissions(MainActivity.this, \n            new String[]{Manifest.permission.CALL_PHONE}, MY_PERMISSIONS_REQUEST_CALL_PHONE);\n    }\n} else {\n    callPhone(String phoneNum);\n}\n```\n# 参考\n- [android调用拨打电话（包括运行时权限）](https://blog.csdn.net/bin622/article/details/72453622)\n- [解决Android6.0+拨打电话权限问题](https://blog.csdn.net/lty406910111/article/details/56288529)","tags":["note"]},{"title":"计算机网络和因特网","url":"/2018/06/25/18/06/计算机网络和英特网/","content":"# 什么是因特网\n## 具体构成描述\n- 因特网是一个世界范围的计算机网络，即它是一个互联了遍及全世界的数以亿计的计算设备的网络。所有这些设备都被称为 **主机**（ host ）或 **端系统**（ end system ）。\n- 端系统通过 **通信链路**（ communication link ）和 **分组交换机**（ packet switch ）连接到一起。\n- 当今的因特网中，两种最著名的分组交换机类型是 **路由器**（ router ）和 **链路层交换机**（ link-layer-switch ）。从发送端系统到接受端系统，一个分组所经历的一系列通信链路和分组交换机称为通过该网络的 **路径**（ route 或 path ）。\n- 端系统通过 **因特网服务提供商**（ Internet Service Providor，**ISP**）接入因特网。\n- 端系统、分组交换机和其他因特网部件都要运行一系列 **协议**（ protocol ），这些协议控制因特网中信息的接受和发送。**TCP**（ Transmission Control Protocol, **传输控制协议**）和 **IP**（ Internet Protocol，**网际协议**）是因特网中两个重要的协议。因特网的主要协议统称为 **TCP/IP**。\n- **因特网标准**（ Internet standard ）由 **因特网工程任务组**（ Internet Engineering Task Force，**IETF**）[ **IETF**2012 ] 研发。**IETF**的标准文档称为 **请求评论**（ Request For Comment，**RFC**）。\n\n## 服务描述\n- **分布式应用程序**（ distributed application )，设计多台相互交换数据的端系统。\n- 与因特网相连的端系统提供了一个 **应用程序编程接口**（ Application Programming Interface，**API**），该API规定了运行在一个端系统上的软件请求因特网基础设施向运行在另一个端系统上的特定目的地软件交付数据的方式。\n\n## 什么是协议\n- 计算机网络中进行数据交换而建立的规则、标准或约定的集合。\n- 网络协议类似于人类协议，除了交换报文和采动作的实体是某些设备的硬件或软件组成（ 这些设备可以是计算机、智能手机、平板电脑、路由器或其他具有网络能力的设备）。\n\n# 网络边缘\n## 接入网\n- **接入网**（ access network ）指将端系统连接到其 **边缘路由器**（ edge router ）的物理链路。\n家庭接入：DSL、电缆、FTTH、拨号和卫星\n企业（ 和家庭 ）接入：以太网和 WIFI\n广域无线接入：3G和LTE\n- **物理媒介**划分为两类：**导引型媒体**（ guided media ）和 **非导引型媒体**（ unguided meida ）。\n双绞铜线，同轴电缆，光纤，陆地无线电信道，卫星无线电信道\n\n## 网络核心\n- 分组交换\n**储存转发传输**（ store-and-forward transmission ），排队时延和分组丢失，转发表和路由选择协议\n- 电路交换\n链路中的电路是通过 **频分复用**（ Frequency-Division Multiplexing，FDM ）或 **时分复用**（ Time-Division Multiplexing，TDM ）来实现的。\n- 网络中的网络\n\n# 参考\n- 计算机网络——自项向下方法","tags":["计算机网络"]},{"title":"Github安装及配置","url":"/2018/06/03/18/06/github安装及配置/","content":"# 什么是Github\n- github是一个基于git的代码托管平台，付费用户可以建私人仓库，我们一般的免费用户只能使用公共仓库，也就是代码要公开。\n\n- [注册](https://github.com/join?source=header-home)Github账户 (已有账号可以跳过此步骤)\n\n## 安装git\n- [下载](https://git-scm.com/downloads/)并安装git\n\n## 配置ssh\n- 右键git bash\n- 设置user.name和user.email\n```bash\ngit config --global user.name \"你的GitHub用户名\"\ngit config --global user.email \"你的GitHub注册邮箱\"\n```\n- 在本地生成ssh密匙\n```bash\nssh-keygen -t rsa -C \"你的GitHub注册邮箱\"\n```\n- 之后会要求确认路径和输入密码，我们这使用默认的一路回车就行。成功的话会在~/下生成.ssh文件夹，进去，打开id_rsa.pub，复制里面的key\n- 回到github上，进入 Account Settings（账户配置），左边选择SSH Keys，Add SSH Key,title随便填，粘贴在你电脑上生成的key。\n![](/img/18/06/github安装及配置.png)\n为了验证是否成功，在git bash下输入：\n```bash\n$ ssh -T git@github.com\n```\n- 如果是第一次的会提示是否continue，输入yes就会看到：You've successfully authenticated, but GitHub does not provide shell access 。这就表示已成功连上github。\n\n## 还是不懂？那看看别人家的\n- [入门级：GitHub和Git超超超详细使用教程！](https://blog.csdn.net/javaandroid730/article/details/53522872)\n- [利用 SSH 完成 Git 与 GitHub 的绑定](https://blog.csdn.net/qq_35246620/article/details/69061355)\n- 还是不懂？还有[绝招](https://www.baidu.com/)!\n\n# 参考\n- [CSDN](https://blog.csdn.net/javaandroid730/article/details/53522872)\n- [菜鸟教程](http://www.runoob.com/w3cnote/git-guide.html)","tags":["github"]},{"title":"JavaScript中的正则表达式","url":"/2018/06/03/18/06/RegExp/","content":"# 1.正则表达式的定义\n## JavaScript中的正则表达式用RegExp对象表示\n- 可以使用RegExp()构造函数来创建对象。以下代码定义了名为pattern的RegExp对象，其模式为\"s\"\n\n```js\nvar pattern = new RegExp(\"s\");\nvar pattern = new RegExp(\"s\",\"i\");\n```\n- 通过一种特殊的直接量语法创建（更多的使用）\n\n```js\nvar pattern = /s/;\nvar pattern = /s/i;\n```\n## 直接量字符\n- 正则表达式语法也支持非字母的字符匹配，这些字符需要通过反斜杠（ \\ ）作为前缀进行转义。\n\n字符|匹配\n :- | :- \n字母和数字字符|自身\n\\o|NUL字符（\\u0000）\n\\t|制表符（\\u0009）\n\\n|换行符（\\u000A）\n\\v|垂直制表符（\\u000B）\n\\f|换页符（\\u000C）\n\\r|回车符（\\u000D）\n\\xnn|由十六进制数nn指定的拉丁字符，例如，\\x0A等价于\\n\n\\uxxxx|由十六进制数xxxx指定的Unicode字符，例如，\\u0009等价于\\t\n\\cX|控制字符^X，例如，\\cJ等价于换行符\\n\n## 字符类\n- 将直接量字符单独放进方括号内就组成了字符类，一个字符类可以匹配它所包括的任意字符。\n\n字符|匹配\n :- | :- \n[...]|方括号内的任意字符\n[^...]|不在方括号内的任意字符\n.|除换行符和其他Unicode行终止符之外的任意字符\n\\w|任何ASCII字符组成的单词，等价于[a-zA-Z0-9]\n\\W|任何不是ASCII字符组成的单词，等价于[^a-zA-Z0-9]\n\\s|任何Unicode空白符\n\\S|任何非Unicode空白符的字符，注意\\w和\\S不同\n\\d|任何ASCII数字，等价于[0-9]\n\\D|除了ASCII数字之外的任何字符，等价于[^0-9]\n[\\b]|退格直接量（特例）\n- 注意：在反括号之内也可以写特殊转义字符。\n\n## 重复\n- 除了用 /\\d\\d/ , /\\d\\d\\d\\d/ 表示两位数和四位数，可以用 重复字符语法。\n\n字符|匹配\n :- | :- \n{n,m}|匹配前一项至少n次，但不能超过m次\n{n,}|匹配前一项n次或者更多次\n{n}|匹配前一项n次\n?|匹配前一项0次或者1次，也就是说前一项是可选的，等价于{0,1}\n+|匹配前一项1次或多次，等价于{1，}\n*|匹配前一项0次或多次，等价于{0，}\n## 非贪婪的重复\n### 贪婪\n- 在上面列出的匹配重复字符是尽可能的多匹配，而且允许后续的正则表达式继续匹配。因此，我们称之为”贪婪的“匹配。\n例如：\n\n```js\n\"aaa\".match(/a+/)\n// [\"aaa\", index: 0, input: \"aaa\"]\n//a+为一到多个a匹配 \n```\n### 非贪婪\n- 我们同样可以使用正则表达式进行非贪婪匹配。只须在待匹配的字符后跟随一个问号即可：“??” 、“+?” 、“*?” 或 “{1,5}”。\n例如：\n\n```js\n\"aaa\".match(/a+?/)\n// [\"a\", index: 0, input: \"aaa\"]  \n//加上?号后为非贪婪模式, 即匹配完成即返回, 不继续  \n```\n**注意：**正则是从左到右开始匹配所有项, 直到匹配为止。那么如下, 它匹配的就应该是整段字符, 而不是单独的一个b \n```js\n\"aaab\".match(/a*?b/)\n// [\"aaab\", index: 0, input: \"aaab\"] \n```\n## 选择、分组和引用\n### 选择\n- 选择项的尝试匹配次序从左到右，知道发现了匹配项。如果左边的选择项匹配，就忽略右边的匹配项，即使他会产生更好的匹配。\n\n```js\n\"ab\".match(/a|ab/)\n// [\"a\", index: 0, input: \"ab\"]\n//它只匹配第一个字符\n```\n### 分组\n- 使用（）把单独的项组合成子表达式，以便可以像处理一个独立的单元那样用 “ | ” 、“ * ” 、“ + ” 、“ ？” 等来对单元内的项进行处理。\n\n```js\n\"abcdef\".match(/(ab|cd)+|ef/)  \n// [\"abcd\", \"cd\", index: 0, input: \"abcdef\"] \n```\n- 在正则表达式中，圆括号的另一个作用是在完整的模式中定义子模式\n\n**注意：**当一个正则表达式成功地和目标字符串相匹配时，可以从目标串中抽出和圆括号中的子模式相匹配的部分。例如：\n```js\n\"aaa111\".match(/[a-z]*\\d/)\n// [\"aaa1\", index: 0, input: \"aaa111\"] \n\"aaa111\".match(/[a-z]*(\\d)/)\n// [\"aaa1\", \"1\", index: 0, input: \"aaa111\"]  \n```\n### 引用\n- 使用带圆括号的表达式允许在同一正则表达式的后部分引用前面的子表达式。通过在字符“\\”后面加一位或多位数字来实现。\n\n**注意：**数字指定了带圆括号的子表达式在正则表达式中的位置，是参与计数的左括号的位置。\n**注意：**引用指的并不是模式的引用，而是指的是与那个模式相匹配的完全相同的字符。\n```js\n\"a'aa1'11\".match(/(['\"])[^'\"]*\\1/)\n// [\"'aa1'\", \"'\", index: 0, input: \"a'aa1'11\"]\n```\n- 在正则表达式中可以使用（？：）创建不带数字编码的引用。\n\n字符|含义\n :- | :- \n&#124;|选择，匹配的是该符号左边的子表达式或右边的子表达式\n(...)|组合，将几个项组合为一个单元，这个单元可通过 ”*“ 、”+“ 、”？“ 和 ”&#124;“ 等符号加以修饰，而且可以记住和这个组合相匹配的字符串以供此后的引用使用\n(?...)|只组合，把项组合到一个单元，但不记忆与该组相匹配的字符\n\\n|和第n个分组第一次匹配的字符相匹配，组是圆括号中的子表达式（也有可能是嵌套的），组索引是从左到右的左括号数，”(?:“ 形式的分组不编码\n## 指定匹配位置\n- 正则表达式中的锚字符\n\n字符|含义\n :- | :- \n^&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|匹配字符串的开头，在多行检索中，匹配一行的开头\n$|匹配字符串的结尾，在多行结尾中，匹配一行的结尾\n\\b|匹配一个单词的边界，简言之，就是位于字符\\w和\\W之间的位置，或位于字符\\w和字符串的开头或者结尾之间的位置（但需要注意，[\\b]匹配的是退格符）\n\\B|匹配非单词边界的位置\n(?=p)|零宽正向先行断言，要求接下来的字符都与p匹配，但不能包括匹配p的那些字符\n(?!p)|零宽负向先行断言，要求接下来的字符不与p匹配\n## 修饰符\n- 用以说明高级匹配模式的规则。\n\n**注意：**修饰符放在 ” / “ 符号之外的，也就是说，它们不是出现在两条斜线之间，而是第二条斜线之后。\n\n字符|含义\n :- | :- \ni|执行不区分大小写的匹配\ng|执行一个全局匹配，简言之，即找到所有的匹配，而不是在找到第一个之后就停止\nm|多行匹配模式，^匹配一行的开头和字符串的开头，$匹配行的结束和字符串的结束\n# 2.用于模式匹配的String方法\n- 讨论String对象的一些用以执行正则表达式模式匹配和检索替换操作的方法\n\n## search()\n- 它的参数是一个正则表达式，返回第一个与之匹配的字串的起始位置\n\n**注意：**如果找不到匹配的子串，它将返回-1。\n**注意：**search()方法不支持全局检索，因此它忽略正则表达式参数中的修饰符g\n\n```js\nstringObject.search(regexp/substr)\n```\n参数|描述\n :- | :-\nregexp/substr|必需。\n```js\n\"JavaScript\".search(/script/i);\n// 返回值为 4\n```\n## replace()\n- 用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。\n\n```js\nstringObject.replace(regexp/substr,replacement)\n```\n参数|描述\n :- | :-\nregexp/substr|必需。规定子字符串或要替换的模式的 RegExp 对象。请注意，如果该值是一个字符串，则将它作为要检索的直接量文本模式，而不是首先被转换为 RegExp 对象\nreplacement|必需。一个字符串值。规定了替换文本或生成替换文本的函数。\n```js\n\"JavaScript\".replace(/script/i, \"SCRIPT\");\n// 返回值为 JavaSCRIPT\n```\n## match()\n- match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。\n\n**注意：**该方法类似 indexOf() 和 lastIndexOf()，但是它返回指定的值，而不是字符串的位置。\n```js\nstringObject.match(searchvalue)\nstringObject.match(regexp)\n```\n参数|描述\n :- | :-\nsearchvalue|必需。规定要检索的字符串值。\nregexp|必需。规定要匹配的模式的 RegExp 对象。如果该参数不是 RegExp 对象，则需要首先把它传递给 RegExp 构造函数，将其转换为 RegExp 对象。\n```js\n\"1 plus 2 equal 3\".match(/\\d+/g);\n// 返回值为 [\"1\", \"2\", \"3\"] 的数组\n```\n## exec()\n- 用于检索字符串中的正则表达式的匹配。\n\n**注意：**返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。\n```js\nRegExpObject.exec(string)\n```\n参数|描述\n :- | :-\nstring|必需。要检索的字符串。\n```js\n/\\d+/g.exec(\"1 plus 2 equal 3\");\n// 返回值为数组,属性 index：0 ，input: \"1 plus 2 equal 3\"\n```\n\n# 参考\n- JavaScript权威指南（第六版）\n- [w3school](http://www.w3school.com.cn/jsref/jsref_replace.asp)\n- [贪婪模式详解](http://lullabyus.iteye.com/blog/1442347)\n- [js正则表达式的选择、分组、引用](https://blog.csdn.net/qq_34356563/article/details/77844689)","tags":["RegExp"]},{"title":"书签","url":"/2018/06/02/18/06/favorite/","content":"## music\n网站|域名\n:- | :-\n尤克里里小站 | http://www.tanukulele.com/\n尤克里里中国网 | http://www.ukulelecn.com/portal.php\n虫虫吉他 | http://www.ccguitar.cn/\n吉他社 | https://www.jitashe.org/\n17吉他 | http://www.17jita.com/\n## video\n网站|域名\n:- | :-\n80s电影网 | www.80s.tw\n哈哩哈哩 | www.halihali.cc\n片源网 | www.pianyuan.net\n99dyy | http://99dyy.cn/\n## resource\n网站|域名\n:- | :-\n优品PPT模板 | www.ypppt.com\n阿里图标库 | www.iconfont.cn\n## studio\n网站|域名\n:- | :-\nHexo | https://hexo.io\nVue.js | https://cn.vuejs.org","tags":["note"]},{"title":"hexo博客安装教程","url":"/2018/06/01/18/06/hexo安装教程/","content":"# 安装Hexo\n## 1.安装node.js\n- 点击[这里](https://nodejs.org/en/)进入node.js官网，并下载安装。\n\n## 2.设置npm淘宝镜像站\n- 默认npm源的下载速度可能很慢，建议使用淘宝镜像\n\n```bash\nnpm config set registry \"https://registry.npm.taobao.org\"\n```\n## 3.安装hexo\n- 执行以下命令\n\n```bash\n# 安装hexo\nnpm install hexo-cli g\n# 初始化博客文件夹（blog为指定的文件夹）\nhexo init blog\n# 切换到该路径\ncd blog\n# 安装hexo的扩展插件\nnpm install\n# 安装其它插件\nnpm install hexo-server --save\nnpm install hexo-admin --save\nnpm install hexo-generator-archive --save\nnpm install hexo-generator-feed --save\nnpm install hexo-generator-search --save\nnpm install hexo-generator-tag --save\nnpm install hexo-deployer-git --save\nnpm install hexo-generator-sitemap --save\n```\n- 测试安装情况，在本地创建服务器使用。\n\n```bash\n# 生成静态页面\nhexo generate\n# 开启本地服务器\nhexo s\n```\n- 在浏览器中输入：http://127.0.0.1:4000 ，如果能看到刚刚创建的博客，那就给自己打call。\n- 当访问 http://127.0.0.1:4000 ，无反应，咋怎呢？\n- 可能是由于端口问题引起的。使用Ctrl+C中断本地服务，使用命令hexo s -p 5000重新开启本地服务，访问http://localhost:5000 可以看到博客页面了。\n\n## 4.准备Github账号\n- 关于Github的教程及配置 [这里](https://blog.csdn.net/qazwsxpcm/article/details/68946736)\n**注意：**要创建仓库和配置好ssh（已配置可跳过此步骤）\n\n## 5.将hexo博客部署到gitHub上\n- 修改配置文件blog/_config.yml，修改deploy项的内容，如下所示：\n\n```\n# Deployment 注释\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  # 类型\n  type: git\n  # 仓库\n  repo: https://github.com/你的Github/仓库名称.git\n  # 分支\n  branch: master\n```\n## 6.部署hexo\n- 输入下面的命令将hexo博客部署到github中：\n\n```bash\n# 清空静态页面\nhexo clean\n# 生成静态页面\nhexo generate\n# 部署 \nhexo deploy\n```\n# hexo命令缩写\n- hexo支持命令缩写，<font style=\"color:red\">hexo g</font>相当于：<font style=\"color:red\">hexo generate</font>\n\n```bash\nhexo g: hexo generate\nhexo c: hexo clean\nhexo s: hexo server\nhexo d: hexo deplop\n```\n# hexo组合命令\n```bash\n# 清除、生成、启动\nhexo clean && hexo g -s\n# 清除、生成、部署\nhexo clean && hexo g -d\n```\n\n# 参考\n- [hexo官方文档](https://hexo.io/zh-cn/)\n- [hexo教程系列——hexo安装教程](https://blog.csdn.net/xuezhisdc/article/details/53130328)","tags":["hexo"]}]